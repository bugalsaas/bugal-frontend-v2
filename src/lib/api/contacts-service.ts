// Contacts API service
import { getToken } from '@/contexts/auth-context';
import { Gender, RelationshipType, RoleType } from '@/lib/types/contact-types';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL;

// State interface for display purposes
export interface State {
  id: string;
  name: string;
  code?: string;
}

// Types for contacts data
export interface Contact {
  id: string;
  // For Clients: firstName and lastName are required
  // For Organisations: organisationName is required
  firstName?: string;
  lastName?: string;
  fullName?: string; // Generated by backend, available for display
  organisationName?: string;
  email?: string;
  mobileNumber?: string; // Changed from phone
  phone?: string; // Keep for backward compatibility/display
  addressLine1?: string;
  addressLine2?: string;
  state?: State | string; // Can be object or string for display
  idState?: string; // State ID for backend
  postcode?: string;
  contactType: ContactType;
  status?: ContactStatus;
  createdAt: string;
  updatedAt: string;
  dob?: string;
  notes?: string;
  // Client-specific fields
  ndisNumber?: string;
  gender?: Gender;
  // Guardian fields
  hasGuardian?: boolean;
  guardianFirstName?: string;
  guardianLastName?: string;
  guardianFullName?: string; // Generated by backend
  guardianEmail?: string;
  guardianPhoneNumber?: string; // Changed from guardianPhone
  guardianPhone?: string; // Keep for backward compatibility
  guardianRelationshipType?: RelationshipType; // Changed from guardianRelationship
  guardianRelationship?: string; // Keep for backward compatibility
  // Organisation contact fields
  hasOrganisationContact?: boolean;
  organisationContactName?: string;
  organisationContactMobileNumber?: string; // Changed from organisationContactPhone
  organisationContactPhone?: string; // Keep for backward compatibility
  organisationContactEmail?: string;
  // Invoice recipients
  invoiceRecipients?: Array<{ email: string; roleType: RoleType; role?: string }>; // roleType is the primary field, role kept for compatibility
  invoices?: Array<{ email: string; roleType: RoleType }>; // Alternative field name used by backend
}

export enum ContactType {
  All = 'All',
  Client = 'Client',
  Organisation = 'Organisation',
  Staff = 'Staff',
}

export enum ContactStatus {
  Active = 'Active',
  Inactive = 'Inactive',
  Archived = 'Archived',
}

export interface ContactFilters {
  type?: ContactType;
  search?: string;
  status?: ContactStatus;
  pageNumber?: number;
  pageSize?: number;
}

export interface ContactListResponse {
  data: Contact[];
  meta: {
    total: number;
    pageNumber: number;
    pageSize: number;
  };
}

// API service functions
export const contactsApi = {
  async getAll(filters: ContactFilters = {}): Promise<ContactListResponse> {
    const token = getToken();
    if (!token) throw new Error('No authentication token');

    const params = new URLSearchParams();
    
    if (filters.type && filters.type !== ContactType.All) {
      params.append('type', filters.type);
    }
    if (filters.search) {
      params.append('text', filters.search);
    }
    if (filters.status) {
      params.append('status', filters.status);
    }
    if (filters.pageNumber) {
      params.append('pageNumber', filters.pageNumber.toString());
    }
    if (filters.pageSize) {
      params.append('pageSize', filters.pageSize.toString());
    }

    const response = await fetch(`${API_BASE_URL}/contacts?${params}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch contacts');
    }

    return response.json();
  },

  async getById(id: string): Promise<Contact> {
    const token = getToken();
    if (!token) throw new Error('No authentication token');

    const response = await fetch(`${API_BASE_URL}/contacts/${id}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch contact');
    }

    return response.json();
  },

  async create(contact: Omit<Contact, 'id' | 'createdAt' | 'updatedAt'>): Promise<Contact> {
    const token = getToken();
    if (!token) throw new Error('No authentication token');

    const response = await fetch(`${API_BASE_URL}/contacts`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(contact),
    });

    if (!response.ok) {
      throw new Error('Failed to create contact');
    }

    return response.json();
  },

  async update(id: string, contact: Partial<Contact>): Promise<Contact> {
    const token = getToken();
    if (!token) throw new Error('No authentication token');

    const response = await fetch(`${API_BASE_URL}/contacts/${id}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(contact),
    });

    if (!response.ok) {
      throw new Error('Failed to update contact');
    }

    return response.json();
  },

  async delete(id: string): Promise<void> {
    const token = getToken();
    if (!token) throw new Error('No authentication token');

    const response = await fetch(`${API_BASE_URL}/contacts/${id}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to delete contact');
    }
  },
};
